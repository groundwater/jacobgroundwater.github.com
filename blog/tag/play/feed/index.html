<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Underflow &#187; play</title>
	<atom:link href="http://www.underflow.ca/blog/tag/play/feed" rel="self" type="application/rss+xml" />
	<link>http://www.underflow.ca/blog</link>
	<description>Thoughts, Ideas, Articles, and Essays by Jacob Groundwater</description>
	<lastBuildDate>Wed, 25 Apr 2012 07:12:26 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=3.4.1</generator>
	<div style="color: #C09853;background-color: #FCF8E3;border: 1px solid #FBEED5;padding: 8px 35px 8px 14px;margin-bottom: 18px;-webkit-border-radius: 4px;-moz-border-radius: 4px;border-radius: 4px;">This site has been archived, for my current blog please go <a href=../../../../index.html>here</a>.</div>	<item>
		<title>HBase, Scala and Play 2</title>
		<link>http://www.underflow.ca/blog/1006/hbase-scala-and-play-2?utm_source=rss&#038;utm_medium=rss&#038;utm_campaign=hbase-scala-and-play-2</link>
		<comments>http://www.underflow.ca/blog/1006/hbase-scala-and-play-2#comments</comments>
		<pubDate>Thu, 19 Apr 2012 10:04:49 +0000</pubDate>
		<dc:creator>jacob</dc:creator>
				<category><![CDATA[Journal]]></category>
		<category><![CDATA[hbase]]></category>
		<category><![CDATA[play]]></category>
		<category><![CDATA[playframework]]></category>
		<category><![CDATA[scala]]></category>

		<guid isPermaLink="false">http://www.underflow.ca/blog/?p=1006</guid>
		<description><![CDATA[I would like to use HBase as my primary go-to data store for Scala and Play applications. Rows in HBase will store Google Protocol Buffers as serialize byte arrays. Non-trivial database access will be handled by coprocessors and client libraries. I would like to mention that even though HBase scales extremely well, that is now why I am choosing it. I like that HBase is simple; it makes no attempt to interpret the data. The job of encapsulating data is entirely up to the protobufs, which are forward-compatible with future changes. Protocol buffers are a flexible, efficient, automated mechanism for serializing structured data … You can even update your data structure without breaking deployed programs that are compiled against the “old” format. — Source Now I certainly do not object to RDBMS, but I prefer not to use them as a global representation of my application. Should a piece of my application require complex transactions, yes an RDBMS is the way to go, however the default data store will be HBase. HBase HBase is what I call a database primitive. HBase is a sparse, distributed, persistent multidimensional sorted map of uninterpreted array of bytes. More… Like any primitive construct, HBase requires a higher-level interface built upon its infrastructure to be useful. HBase can be downloaded from the apache website and immediately operated standalone mode. Standalone is production-ready, but does not use HDFS as the underlying file system, thus data is susceptible to corruption. HDFS is a distributed file system that requires no underlying RAID, as every block is replicated to 3 machines. Standalone HBase is no more volatile than a standalone MySQL instance, so use that as your yardstick. Another advantage of HBase, you can use a single HBase cluster to host all your applications. I recommend following the Quick Start Guide before proceeding. HBase with Play Play requires only the following dependencies to connect to an HBase instance: Make sure you’re using the same client version as the HBase server! Here is a minimal Play application that connects to an existing coprocessor. That’s it! Simple no? A quick reminder, always start HBase before your applications. Should HBase need to be restarted, you should also restart your play application. Coprocessors First, apologies. I coded the coprocessor section in Java because... okay I'm not sure, just forgive me. One of the primitives provided by HBase is something called a coprocessor. A coprocessor is a type of inverted control. Instead of querying the database by calling database functions, you pass the database a program that directly walks the underlying data-structure. These programs are called coprocessors. Coprocessors use RPCs to communicate between the client code and database. Like other RPC implementations we need to define a remote interface, and a local class that satisfies the interface. The remote interface must extend CoprocessorProtocol. Any class that satisfies the above interface can be used as the local implementation, however HBase provides the abstract class BaseEndpointCoprocessor for convenience. The BaseEndpointCoprocessor class contains a getEnvironment() method to [...]]]></description>
			<content:encoded><![CDATA[<p>I would like to use <a href="http://hbase.apache.org/">HBase</a> as my primary go-to data store for Scala and <a href="http://www.playframework.org/">Play</a> applications.
Rows in HBase will store <a href="http://code.google.com/p/protobuf/">Google Protocol Buffers</a> as serialize byte arrays.
Non-trivial database access will be handled by coprocessors and client libraries.</p>

<p>I would like to mention that even though HBase scales extremely well, that is now why I am choosing it.
I like that HBase is simple; it makes no attempt to interpret the data.
The job of encapsulating data is entirely up to the protobufs, which are forward-compatible with future changes.</p>

<blockquote>
  <p>Protocol buffers are a flexible, efficient, automated mechanism for serializing structured data … You can even update your data structure without breaking deployed programs that are compiled against the “old” format. — <a href="https://developers.google.com/protocol-buffers/docs/overview">Source</a></p>
</blockquote>

<p>Now I certainly do not object to RDBMS, but I prefer not to use them as a <em>global</em> representation of my application.
Should a piece of my application require complex transactions, yes an RDBMS is the way to go, however the default data store will be HBase.</p>

<h2>HBase</h2>

<p>HBase is what I call a database primitive.
HBase is a sparse, distributed, persistent multidimensional sorted map of uninterpreted array of bytes. <a href="http://jimbojw.com/wiki/index.php?title=Understanding_Hbase_and_BigTable">More…</a></p>

<p>Like any primitive construct, HBase requires a higher-level interface built upon its infrastructure to be useful.</p>

<p>HBase can be downloaded from the <a href="http://hbase.apache.org/">apache website</a> and immediately operated standalone mode.
Standalone is production-ready, but does not use HDFS as the underlying file system, thus data is susceptible to corruption.
HDFS is a distributed file system that requires no underlying RAID, as every block is replicated to 3 machines.
Standalone HBase is no more volatile than a standalone MySQL instance, so use that as your yardstick.
Another advantage of HBase, you can use a single HBase cluster to host <em>all</em> your applications.</p>

<p>I recommend following the <a href="http://hbase.apache.org/book/quickstart.html">Quick Start Guide</a> before proceeding.</p>

<h2>HBase with Play</h2>

<p>Play requires only the following dependencies to connect to an HBase instance:</p>

<pre><pre class="brush: plain; title: ; notranslate">
&quot;org.apache.hadoop&quot; % &quot;hadoop-core&quot; % &quot;1.0.2&quot;

&quot;org.apache.hbase&quot;  % &quot;hbase&quot;       % &quot;0.92.1&quot;
</pre></pre>

<p><em>Make sure you’re using the same client version as the HBase server!</em></p>

<p>Here is a minimal Play application that connects to an <a href="https://github.com/jacobgroundwater/HBase-Coprocessors-and-Play/blob/master/HBaseCoprocessors/src/main/java/ca/underflow/hbase/Simple.java">existing coprocessor</a>.</p>

<pre><pre class="brush: scala; title: ; notranslate">
object Application extends Controller {

    val conf = HBaseConfiguration.create()
    val table: HTableInterface = new HTable(conf, &quot;demo&quot;)

    def index = Action {

        val byt = Bytes.toBytes(&quot;row1&quot;)
        val proxy = table.coprocessorProxy(classOf[Simple],byt)

        // proxy is the RPC interface to your coprocessor
        Ok( proxy.poll() )

    }

}
</pre></pre>

<p>That’s it! Simple no?</p>

<p>A quick reminder, always start HBase <em>before</em> your applications.
Should HBase need to be restarted, you should also restart your play application.</p>

<h2>Coprocessors</h2>

<p>First, apologies. I coded the coprocessor section in Java because... okay I'm not sure, just forgive me.</p>

<p>One of the primitives provided by HBase is something called a coprocessor.
A coprocessor is a type of inverted control. 
Instead of querying the database by calling database functions, you pass the database a program that directly walks the underlying data-structure.
These programs are called coprocessors.</p>

<p>Coprocessors use RPCs to communicate between the client code and database.
Like other RPC implementations we need to define a remote interface, and a local class that satisfies the interface.</p>

<p>The remote interface must extend <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/ipc/CoprocessorProtocol.html"><code>CoprocessorProtocol</code></a>.</p>

<pre><pre class="brush: scala; title: ; notranslate">
public interface Simple extends CoprocessorProtocol {

    // Very simple example that returns some 
    // information about the database
    public String about() throws IOException;
    
}
</pre></pre>

<p>Any class that satisfies the above interface can be used as the local implementation,
however HBase provides the abstract class <a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/coprocessor/BaseEndpointCoprocessor.html"><code>BaseEndpointCoprocessor</code></a> for convenience.
The <code>BaseEndpointCoprocessor</code> class contains a <code>getEnvironment()</code> method to help access the data store.</p>

<p>Coprocessors have two flavours, Observers and Endpoints.
Observers watch the underlying table and intercept method calls transparently to the client.
An observer can only modify an incoming request, or throw an IOException to cancel the request.
Since observers are transparent to the client, I think their behaviour cannot be checked by the compiler.
If you want complex behavioural changes, it's probably better to use an Endpoint, since it creates a new interface between the client and server than can be type checked.</p>

<p>An endpoint coprocessors needs to be</p>

<ol>
<li>in the hbase classpath (set in <code>hbase-env.sh: HBASE_CLASSPATH</code>)</li>
<li><p>have an implementation specified in <code>hbase-site.xml</code></p>
</ol>
<pre><pre class="brush: xml; title: ; notranslate">
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
  &lt;value&gt;ca.underflow.hbase.SimpleExec&lt;/value&gt;
&lt;/property&gt;
</pre></pre>

<p>A coprocessor loaded by the above configuration can be implemented as follows:</p>

<pre><pre class="brush: scala; title: ; notranslate">
public class SimpleImpl extends BaseEndpointCoprocessor 
        implements Simple {

    public String about() throws IOException {

        RegionCoprocessorEnvironment env = 
                (RegionCoprocessorEnvironment) getEnvironment();
        HRegion region = env.getRegion();

        return region.getRegionNameAsString();

    }
}
</pre></pre>

<p>The <code>CoprocessorEnvironment</code> can be cast to <code>RegionCoprocessorEnvironment</code> because it was loaded via <code>hbase.coprocessor.region.classes</code> in the <code>hbase-site.xml</code> configuration file.</p>

<p>Coprocessors are a lot like wrappers for libraries, in fact there is nothing that a coprocessor can do that a client library cannot.
The principal advantage of coprocessors is performance.
By executing on the data store directly, there is much less cross-network traffic involved during multi-stage operations.</p>

<p>From an RPC standpoint, coprocessors add new method calls to your database interface.</p>

<h2>Lessons Learned</h2>

<p>My first idea was to create a coprocessor that accepted Google Protocol Buffers (Protobuf) and transparently serialized them to the database. 
A complimentary de-serialization process would make HBase appear to the client like a Protobuf storage system.
Behold the problems with my logic.</p>

<p>The coprocessors would have to de-serialize the protobufs directly, but that would require having every buffer on the HBase class-path. In addition, de-serialization requires a lot of internal reflection, extra unnecessary code. It makes much more sense to interpret the serialized bytes in the client code.</p>

<p>Coprocessors should be used to encapsulate logic that would require multiple trips to the database to complete.
Higher level encapsulation should be defined in the application.</p>

<h3>Examples</h3>
<div style="padding:15px; margin:15px;border:1px dotted black; text-align:center;">
I have posted some working code on <a href="https://github.com/jacobgroundwater/HBase-Coprocessors-and-Play">my github</a> page.
</div>

<h2>References</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/8224907/re-download-a-snapshot-version-of-a-dependency-using-sbt">http://stackoverflow.com/questions/8224907/re-download-a-snapshot-version-of-a-dependency-using-sbt</a></li>
<li><a href="http://www.thecloudavenue.com/2012/02/getting-started-with-hbase_20.html">http://www.thecloudavenue.com/2012/02/getting-started-with-hbase_20.html</a></li>
<li><a href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/ipc/CoprocessorProtocol.html">http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/ipc/CoprocessorProtocol.html</a></li>
</ul>]]></content:encoded>
			<wfw:commentRss>http://www.underflow.ca/blog/1006/hbase-scala-and-play-2/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Play[ing] with Actions</title>
		<link>http://www.underflow.ca/blog/798/playing-with-actions?utm_source=rss&#038;utm_medium=rss&#038;utm_campaign=playing-with-actions</link>
		<comments>http://www.underflow.ca/blog/798/playing-with-actions#comments</comments>
		<pubDate>Tue, 17 Apr 2012 05:42:05 +0000</pubDate>
		<dc:creator>jacob</dc:creator>
				<category><![CDATA[Journal]]></category>
		<category><![CDATA[actions]]></category>
		<category><![CDATA[mvc]]></category>
		<category><![CDATA[play]]></category>
		<category><![CDATA[playframework]]></category>
		<category><![CDATA[programming]]></category>
		<category><![CDATA[scala]]></category>

		<guid isPermaLink="false">http://www.underflow.ca/blog/?p=798</guid>
		<description><![CDATA[Introduction Actions in the Play framework could also be called Request Processors. They are designed in such a way that it is easy to compose actions to create rich controller behaviour without excess code clutter. In Play, incoming HTTP requests are matched against the conf/routes file and routed to a single controller method. These methods must return an Action object, or any object satisfying the interface: Looking closer, the controller does not actually handle the request, but generates an object that will handle it. A controller can even re-use objects as the following trivial example shows: In each case, only a single object is created and used to handle each request. Why then create multiple objects? It's not really necessary unless you have concurrency-issues or closures in the action that are time-dependent. Syntax The syntax of an action can catch you off guard, especially for newcomers to Scala like myself. The code can be rewritten as The apply method accepts either a Result type, or a Request[A]=>Result type. Composing Actions Actions can be composed in a way that maintains code clarity in your controller code. Not only can actions pre-process requests, they can inject new values into other actions. For example: The first action Authenticated will read the request and parse out the current user, providing the user object in the scope of the second action. Any number of actions can be combined in this way, there are endless possibilities. I like actions because they promote re-usable code. Actions exhibit just the right abstractions to be useful, however figuring out how to code an Action can be difficult. I have provided some templates: Single Injection Use the following template for creating your own actions. This example injects a single variable into the scope of the next: Actions are monadic, they invert control of the application. Any action may return early, effectively terminating the chain of actions. Terminations are handled gracefully, exceptions are not necessary to interrupt the chain.]]></description>
			<content:encoded><![CDATA[<h2>Introduction</h2>
<p>Actions in the Play framework could also be called <strong>Request Processors</strong>. They are designed in such a way that it is easy to compose actions to create rich controller behaviour without excess code clutter.</p>
<p>In Play, incoming HTTP requests are matched against the <code>conf/routes</code> file and routed to a single controller method. These methods must return an <code>Action</code> object, or any object satisfying the interface:</p>
<pre><pre class="brush: scala; title: ; notranslate">
Request[A] =&gt; Result
</pre>
<p>Looking closer, the controller does not actually handle the request, but generates an object that will handle it. A controller can even re-use objects as the following trivial example shows:</p>
<pre><pre class="brush: scala; title: ; notranslate">
object Application extends Controller {
    val page1 = Action { Ok(&quot;Hello&quot;) } 
    val page2 = page1
    val page3 = page2
}
</pre>
<p>In each case, only a single object is created and used to handle each request. Why then create multiple objects? It's not really necessary unless you have concurrency-issues or closures in the action that are time-dependent.</p>
<h2>Syntax</h2>
<p>The syntax of an action can catch you off guard, especially for newcomers to Scala like myself. The code</p>
<pre><pre class="brush: scala; title: ; notranslate">
object Application extends Controller {
	def page1 = Action { Ok(&quot;Hello&quot;) } 
}
</pre>
<p>can be rewritten as</p>
<pre><pre class="brush: scala; title: ; notranslate">
object Application extends Controller {
    val f : Result = { Ok(&quot;Hello&quot;) }
    def page1 = Action( f )
    // i.e. Action.apply( f )
}
</pre>
<p>The <code>apply</code> method accepts either a <code>Result</code> type, or a <code>Request[A]=>Result</code> type. </p>
<h2>Composing Actions</h2>
<p>Actions can be composed in a way that maintains code clarity in your controller code. Not only can actions pre-process requests, they can inject new values into other actions. For example:</p>
<pre><pre class="brush: scala; title: ; notranslate">
object Application extends Controller {
    def home = Authenticated { implicit user =&gt; 
        Action { implicit request =&gt;
            Ok( views.html.hello(user) )
        }
    }
}
</pre>
<p>The first action <code>Authenticated</code> will read the request and parse out the current user, providing the user object in the scope of the second action. Any number of actions can be combined in this way, there are endless possibilities.</p>
<p>I like actions because they promote re-usable code. Actions exhibit just the right abstractions to be useful, however figuring out how to code an <code>Action</code> can be difficult. I have provided some templates:</p>
<h3>Single Injection</h3>
<p>Use the following template for creating your own actions. This example injects a single variable into the scope of the next:</p>
<pre><pre class="brush: scala; title: ; notranslate">
trait InjectionAction[A] extends Action[A]
object InjectionAction {
    def apply[A] (bodyParser: BodyParser[A])
                 (block: INJECTED_TYPE =&gt; Request[A] =&gt; Result ) = 
                 new InjectionAction[A] {
        def parser = bodyParser
        def apply(request: Request[A]) = {
            val injected = // Anything you wish, can access request object
            block(injected)(request)
        }
    }
    def apply (block: INJECTED_TYPE =&gt; 
                      Request[AnyContent] =&gt; 
                      Result): InjectionAction[AnyContent] = {
        InjectionAction(BodyParsers.parse.anyContent)(block)
    }
}
</pre>
<p>Actions are monadic, they invert control of the application. Any action may return early, effectively terminating the chain of actions. Terminations are handled gracefully, exceptions are not necessary to interrupt the chain. </p>
]]></content:encoded>
			<wfw:commentRss>http://www.underflow.ca/blog/798/playing-with-actions/feed</wfw:commentRss>
		<slash:comments>11</slash:comments>
		</item>
		<item>
		<title>Preventing CSRF in Scala and Play! [2.0]</title>
		<link>http://www.underflow.ca/blog/774/preventing-csrf-in-scala-and-play-2-0?utm_source=rss&#038;utm_medium=rss&#038;utm_campaign=preventing-csrf-in-scala-and-play-2-0</link>
		<comments>http://www.underflow.ca/blog/774/preventing-csrf-in-scala-and-play-2-0#comments</comments>
		<pubDate>Sun, 01 Apr 2012 16:48:25 +0000</pubDate>
		<dc:creator>jacob</dc:creator>
				<category><![CDATA[Journal]]></category>
		<category><![CDATA[csrf]]></category>
		<category><![CDATA[play]]></category>
		<category><![CDATA[playframework]]></category>
		<category><![CDATA[scala]]></category>
		<category><![CDATA[security]]></category>

		<guid isPermaLink="false">http://www.underflow.ca/blog/?p=774</guid>
		<description><![CDATA[Any web developer must keep in mind modern attack vectors in web development. Most are easily preventable. What are Cross Site Request Forgeries? Quite simply, the web was not designed from the ground up to meet todays needs and applications. The web is a sea of slowly evolving standards and technologies, most of which have outgrown their original purpose long ago. Submitting form data is one such technology that cannot keep pace with todays needs. The biggest problem by far is the lack of authenticity behind incoming form data. This is a combination of how HTML, web-browsers and HTTP work; the bottom line is that you must take steps to ensure you are accepting only legitimate requests. Standard Defense Techniques The most standard common defense method today is by signing each form with hidden data that can be authenticated. Thus every legitimate incoming request should contain data that can authenticate the entire form. Example Whenever a new session is opened, a unique session key (a random string) is generated and stored as a cookie on the users browser. Both the server and client now know this value, however a third-party should never know the value. A third-party has a number of attack vectors, the CSRF involves having a user submit a malicious form originating on one website but targeted at another. The submitted form will also carry with it any cookie values the user may have, including logged in sessions. This could, for example, be used to auto-post status updates on social news sites behind the users back. For this attack to work, the third-party must construct and host the complete form. Because of this their form should never contain our randomly generated session key. If our site requires and validates a session key with each form submission the third-parties forms will never pass validation. Play! [2.0] Example Play is a full stack Scala framework for rapid web application development. Scala compiles and executes on the JVM but does not use servlets. Play presents its own idioms for creating applications and follows a Model-View-Controller architecture. A controller creates Action objects that parse HTTP requests. Actions can be chained together, which makes adding CSRF protection very easy. Generate the Session Key and Sign the Form Create and chain an extra action that checks for a session key (or generates a new one) and passes it to the next action. Validate Incoming Forms A corresponding action to check for signed formes can be chained to other actions. An invalid form will generate a Bad Request error. In order to insert the session key into the form, your template must both accept and write the key to the page. I've posted the full example to my github page.]]></description>
			<content:encoded><![CDATA[<p>Any web developer must keep in mind modern attack vectors in web development. Most are easily preventable.</p>
<h2>What are Cross Site Request Forgeries?</h2>
<p>Quite simply, the web was not designed from the ground up to meet todays needs and applications. The web is a sea of slowly evolving standards and technologies, most of which have outgrown their original purpose long ago.</p>
<p>Submitting form data is one such technology that cannot keep pace with todays needs. The biggest problem by far is the lack of authenticity behind incoming form data. This is a combination of how HTML, web-browsers and HTTP work; the bottom line is that you must take steps to ensure you are accepting only legitimate requests.</p>
<h2>Standard Defense Techniques</h2>
<p>The most standard common defense method today is by <strong>signing</strong> each form with hidden data that <em>can</em> be authenticated. Thus every legitimate incoming request should contain data that can authenticate the entire form.</p>
<h3>Example</h3>
<p>Whenever a new session is opened, a unique session key (a random string) is generated and stored as a cookie on the users browser. Both the server and client now know this value, however a third-party should never know the value.</p>
<p>A third-party has a number of attack vectors, the CSRF involves having a user submit a malicious form originating on one website but targeted at another. The submitted form will also carry with it any cookie values the user may have, including logged in sessions. This could, for example, be used to auto-post status updates on social news sites behind the users back. </p>
<p>For this attack to work, the third-party must construct and host the complete form. Because of this their form should never contain our randomly generated session key. If our site requires and validates a session key with each form submission the third-parties forms will never pass validation.</p>
<h2>Play! [2.0] Example</h2>
<p>Play is a full stack Scala framework for rapid web application development. Scala compiles and executes on the JVM but does not use servlets. Play presents its own idioms for creating applications and follows a Model-View-Controller architecture.</p>
<p>A controller creates Action objects that parse HTTP requests. Actions can be chained together, which makes adding CSRF protection very easy.</p>
<h3>Generate the Session Key and Sign the Form</h3>
<p>Create and chain an extra action that checks for a session key (or generates a new one) and passes it to the next action.</p>
<pre><pre class="brush: scala; highlight: [2]; title: ; notranslate">
class Application extends Controller {
    def login = SessionKey{ (key,signature) =&gt; 
    	Action { implicit request =&gt;
    		Ok( views.html.login(signature) ).withSession( key-&gt;signature )
    	}
    }
}
</pre>
<h3>Validate Incoming Forms</h3>
<p>A corresponding action to check for signed formes can be chained to other actions. An invalid form will generate a Bad Request error.</p>
<pre><pre class="brush: scala; highlight: [2]; title: ; notranslate">
class Security extends Controller {
    def login = ValidateForm {
    	Action { implicit request =&gt;
	    Ok(&quot;Okay&quot;)
        }
    }
}
</pre>
<p>In order to insert the session key into the form, your template must both accept and write the key to the page.</p>
<pre><pre class="brush: xml; highlight: [6]; title: ; notranslate">
@(key: String)
&lt;form id=&quot;form-login&quot; action=&quot;/login&quot; method=&quot;POST&quot;&gt;
    &lt;input type=&quot;submit&quot; name=&quot;username&quot; value=&quot;username&quot;/&gt;
    &lt;input type=&quot;submit&quot; name=&quot;password&quot; value=&quot;password&quot;/&gt;
    &lt;input type=&quot;submit&quot; name=&quot;submit&quot;   value=&quot;Submit&quot;/&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;sessionkey&quot; value=&quot;@key&quot;/&gt;
&lt;/form&gt;
</pre>
<p>I've posted the full example to my <a href="https://github.com/jacobgroundwater/Scala-Play-CSRF">github page</a>.</p>
]]></content:encoded>
			<wfw:commentRss>http://www.underflow.ca/blog/774/preventing-csrf-in-scala-and-play-2-0/feed</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>Scala, Play! and Databases</title>
		<link>http://www.underflow.ca/blog/606/scala-play-and-databases?utm_source=rss&#038;utm_medium=rss&#038;utm_campaign=scala-play-and-databases</link>
		<comments>http://www.underflow.ca/blog/606/scala-play-and-databases#comments</comments>
		<pubDate>Mon, 26 Mar 2012 02:07:37 +0000</pubDate>
		<dc:creator>jacob</dc:creator>
				<category><![CDATA[Journal]]></category>
		<category><![CDATA[anorm]]></category>
		<category><![CDATA[database]]></category>
		<category><![CDATA[lean-startup]]></category>
		<category><![CDATA[pattern-matching]]></category>
		<category><![CDATA[play]]></category>
		<category><![CDATA[playframework]]></category>
		<category><![CDATA[programming]]></category>
		<category><![CDATA[rapid-application-development]]></category>
		<category><![CDATA[scala]]></category>
		<category><![CDATA[sql]]></category>

		<guid isPermaLink="false">http://www.underflow.ca/blog/?p=606</guid>
		<description><![CDATA[I keep thinking that Play! is a Scala version of Ruby on Rails. I'm also drinking the Lean Startup cool-aid, so rapid application development pre-empts doing it right1. I'm interested to know how quickly and easily I can throw up an application. When planning a project, I often think first of the data I wish to store. The speed at which I can define and modify the data model is important. The Play! framework comes with Anorm, a low-level yet pragmatic layer to manage persistent objects. Anorm is basically a collection of clever methods for generating and parsing SQL queries, and interfacing with the JDBC layer. It is not an ORM2, however Anorm provides a lot of tools to create your own ORM with very little code. In fact, you just may end up writing less code that using Java annotations with JPA or Hibernate. You can create your classes any way you wish, but most people use case classes because the compiler does half the work for you3. Here, it's typical (but not required) to create a companion object in the same file to handle the ORM functionality. This is handy if your object has private members, since the companion object will have access to those fields. In the companion object you can create any methods here you wish, for example: create - create a new saved object update - update a previously saved object findAll - retrieve all saved objects find - retrieve a saved object identified by a specific key Eager coders might want to combine create and update into a single method. That's probably a good idea, but it would pollute the introductory material here. Define your companion object as follows: Your controllers specified in /app/controllers will then use code similar to the following snippets: To Create and Save a New Person: To Retrieve an Existing Person: Writing Queries Okay time to complete those methods in your Person object. We must manually decide how the database table is structured, and write the query that will create it. These are called database evolutions and they belong in the file conf/evolutions/default/1.sq. As we create more evolutions later, they will go into files 2.sql and so on. You can design your database any way you wish, it just has to be consistent between the SQL definitions in your evolution files, and the code in your Person object. Here is a snipped of the evolution file4: The code to save an object would be simple, if not for the fact that we should retrieve the newly created primary key associated with the newly saved object. The executeInsert() method returns the optional value Option[Long]5. Use match to extract the primary key. Notice this method will generate a new row in the database each time it's called, even if called twice on the same object. The executeInsert code is useful because it return the new primary key. The Primary key is not automatically added to the Person object. Another implementation would insert [...]]]></description>
			<content:encoded><![CDATA[<p>I keep thinking that Play! is a Scala version of Ruby on Rails. I'm also drinking the Lean Startup cool-aid, so rapid application development pre-empts doing it <em>right</em><sup><a href="../../../606/scala-play-and-databases/index.html#footnote_0_606" id="identifier_0_606" class="footnote-link footnote-identifier-link" title="See Pretotyping by Jeremy Clark and Patrick Copeland">1</a></sup>. I'm interested to know how quickly and easily I can throw up an application.</p>
<div id='stb-container-290' class='stb-container'><div id='stb-caption-box-290' class='stb-info-caption_box stb_caption' >Note</div><div id='stb-body-box-290' class='stb-info-body_box stb_body' ></p>
<div style="text-align:justify; padding:0 25px;">I write these blogs not as an expert, but as someone learning these topics for the first time. </p>
<p>I choose to write them now because I can better identify the points of confusion in learning the material and address them. My examples are not always the best or most advanced way of doing things; in fact they are usually not the way you would write production code. What I attempt to do is focus in on thing at a time, leaving all else as simple as possible to avoid unnecessary confusion. </p>
<p>I will, whenever possible, include links to more complete references.</p></div>
<p></div></div>
<p>When planning a project, I often think first of the data I wish to store. The speed at which I can define and modify the data model is important. The Play! framework comes with Anorm, a low-level yet pragmatic layer to manage persistent objects.</p>
<p>Anorm is basically a collection of clever methods for generating and parsing SQL queries, and interfacing with the JDBC layer. It is not an ORM<sup><a href="../../../606/scala-play-and-databases/index.html#footnote_1_606" id="identifier_1_606" class="footnote-link footnote-identifier-link" title="See the Anorm Documentation">2</a></sup>, however Anorm provides a lot of tools to create your own ORM with very little code. In fact, you just may end up writing less code that using Java annotations with JPA or Hibernate.</p>
<p>You can create your classes any way you wish, but most people use case classes because the compiler does half the work for you<sup><a href="../../../606/scala-play-and-databases/index.html#footnote_2_606" id="identifier_2_606" class="footnote-link footnote-identifier-link" title="The compiler generates a companion object, giving you access to the staticy method MyObject() vs. calling new MyObject(). See Scala for the Impatient by Cay Horstmann">3</a></sup>.</p>
<pre><pre class="brush: scala; title: ; notranslate">
import anorm.Pk

case class Person( 
    var id: Pk[Long], 
    var firstName: String, 
    var lastName: String 
)
</pre>
<div id='stb-container-1664' class='stb-container'><div id='stb-caption-box-1664' class='stb-black-caption_box stb_caption' >Note</div><div id='stb-body-box-1664' class='stb-black-body_box stb_body' ><br />
There is a lot of debate about creating mutable case classes. Most notably that the compiler overrides the <code>hash</code> method creating a time-dependent hash of your object.</p>
<p>I'm the type of person who believes that any style works, as long as you bear in mind the consequences. Yes, there are perhaps better ways. That is left as an exercise to the reader =]<br />
</div></div>
<p>Here, it's typical (but not required) to create a companion object in the same file to handle the ORM functionality. This is handy if your object has private members, since the companion object will have access to those fields.</p>
<p>In the companion object you can create any methods here you wish, for example:</p>
<ol>
<li><code>create</code> - create a new saved object</li>
<li><code>update</code> - update a previously saved object</li>
<li><code>findAll</code> - retrieve all saved objects</li>
<li><code>find</code> - retrieve a saved object identified by a specific key</li>
</ol>
<p>Eager coders might want to combine <code>create</code> and <code>update</code> into a single method. That's probably a good idea, but it would pollute the introductory material here. </p>
<p>Define your companion object as follows:</p>
<pre><pre class="brush: scala; title: ; notranslate">
object Person {
    def create( p:Person ) : Pk[Long] = {...}
    def update( p:Person ) {...}
    def find( id:Long ) : Person = {...}
    def findAll() : List[Person] = {...}
}
</pre>
<p>Your controllers specified in <code>/app/controllers</code> will then use code similar to the following snippets:</p>
<p><strong>To Create and Save a New Person:</strong></p>
<pre><pre class="brush: scala; title: ; notranslate">
import anorm.NotAssigned

// let the database set the primary key
val me = Person( id:NotAssigned, firstName:&quot;Big&quot;, lastName:&quot;Guy&quot; )

Person.create(me)
</pre>
<p><strong>To Retrieve an Existing Person:</strong></p>
<pre><pre class="brush: scala; title: ; notranslate">
// Assuming we have an object with Primary Key = 12
val person = Person.find(12)
</pre>
<h2>Writing Queries</h2>
<p>Okay time to complete those methods in your <code>Person</code> object. We must manually decide how the database table is structured, and write the query that will create it. These are called database evolutions and they belong in the file <code>conf/evolutions/default/1.sq</code>. As we create more evolutions later, they will go into files <code>2.sql</code> and so on.</p>
<p>You can design your database any way you wish, it just has to be consistent between the SQL definitions in your evolution files, and the code in your <code>Person</code> object. Here is a snipped of the evolution file<sup><a href="../../../606/scala-play-and-databases/index.html#footnote_3_606" id="identifier_3_606" class="footnote-link footnote-identifier-link" title="See Managing Database Evolutions on how to write the complete file.">4</a></sup>:</p>
<pre class="brush: sql; title: ; notranslate">
CREATE TABLE todo (
  id          SERIAL PRIMARY KEY,
  firstName   VARCHAR(255),
  lastName    VARCHAR(255)
);
</pre>
<p>The code to save an object would be simple, if not for the fact that we should retrieve the newly created primary key associated with the newly saved object. The <code>executeInsert()</code> method returns the optional value <code>Option[Long]</code><sup><a href="../../../606/scala-play-and-databases/index.html#footnote_4_606" id="identifier_4_606" class="footnote-link footnote-identifier-link" title="See Scala Options: http://www.scala-lang.org/api/current/scala/Option.html">5</a></sup>. Use <code>match</code> to extract the primary key.</p>
<pre><pre class="brush: scala; title: ; notranslate">
object Person {
    def create(p:Person) : Pk[Long] {
        
        // Open the default database
        DB.withConnection (&quot;default&quot;) { implicit connection =&gt;
            
            // Use string-replacement to construct the SQL query
            SQL(&quot;&quot;&quot;INSERT INTO person(firstName,lastName) 
                 values ({firstName},{lastName})&quot;&quot;&quot;).on(
                &quot;firstName&quot; -&gt; p.firstName,
                &quot;lastName&quot;  -&gt; p.lastName
            
            // Execute the statement
            ).executeInsert() // returns Option[Long] 
        } match {
            
            // Extracts the Long value, if it exists
            case Some(long) =&gt; new Id[Long](long)
            
            // If no value is returned, the Insert failed
            case None    =&gt; throw new Exception(
               &quot;SQL Error - Did not save Person&quot;
            )
        }
        p
    }
}
</pre>
<p>Notice this method will generate a new row in the database each time it's called, even if called twice on the same object. The <code>executeInsert</code> code is useful because it return the new primary key.</p>
<p>The Primary key is not automatically added to the <code>Person</code> object. Another implementation would insert the primary key into <code>Person</code> and return the <em>tagged</em> object.</p>
<h2>Retrieval</h2>
<p>Retrieving an object is tricker, at first. Anorm lends a hand with something called a <code>RowParser</code>. The parser is the piece that asserts types coming from the database.</p>
<p>A parser is created by joining smaller parsers together by the tilde (~) method. The following is a parser:</p>
<pre><pre class="brush: scala; title: ; notranslate">
import anorm.SqlParser.{get,str}
import anorm.Pk

val rowparser = get[Pk[Long]](&quot;id&quot;) ~ str(&quot;firstName&quot;) ~ str(&quot;lastName&quot;)
</pre>
<p>The above will extract the rows named "id", "firstName", and "lastName"; the types <code>Pk[Long]</code>, <code>String</code>, and <code>String</code> will be checked against the results coming from the database.</p>
<p>Okay, now comes the pattern-matching-gymnastics. The following could be contained in your <code>findAll</code> method. I have added types signatures for clarity.</p>
<pre><pre class="brush: scala; title: ; notranslate">
// Create a row parser object
val rp: RowParser[Pk[Long]~String~String] = 
    get[Pk[Long]](&quot;id&quot;) ~ str(&quot;firstName&quot;) ~ str(&quot;lastName&quot;)

DB.withConnection { implicit connection =&gt;

    // Parse All Results from SQL Statement
    val rsp : ResultSetParser[List[Pk[Long]~String~String]] = rp *

    // The type of results depends on the type of rsp
    // In this case List[Pk[Long]~String~String]
    val results = SQL(&quot;SELECT * FROM person&quot;) as ( rsp )

    // Use pattern matching to re-construct our objects
    results map {
        case pk~fname~lname =&gt; Person(pk,fname,lname)
    }

}
</pre>
<p>From here you can get creative. Clearly pattern matching can be stored and reused. It also has the nice property of not caring about exactly <em>what</em> the SQL statement returned, it will do it's best to extract the necessary column data.</p>
<h2>Footnotes</h2>
<ol class="footnotes"><li id="footnote_0_606" class="footnote">See <a href="http://www.pretotyping.org/">Pretotyping</a> by Jeremy Clark and Patrick Copeland</li><li id="footnote_1_606" class="footnote">See the <a href="https://github.com/playframework/Play20/wiki/ScalaAnorm">Anorm Documentation</a></li><li id="footnote_2_606" class="footnote">The compiler generates a companion object, giving you access to the <em>staticy</em> method <code>MyObject()</code> vs. calling <code>new MyObject()</code>. See <a href="http://typesafe.com/resources/scala-for-the-impatient">Scala for the Impatient</a> by Cay Horstmann</li><li id="footnote_3_606" class="footnote">See <a href="http://www.playframework.org/documentation/2.0/Evolutions">Managing Database Evolutions</a> on how to write the complete file.</li><li id="footnote_4_606" class="footnote">See Scala Options: <a href="http://www.scala-lang.org/api/current/scala/Option.html">http://www.scala-lang.org/api/current/scala/Option.html</a></li></ol>]]></content:encoded>
			<wfw:commentRss>http://www.underflow.ca/blog/606/scala-play-and-databases/feed</wfw:commentRss>
		<slash:comments>7</slash:comments>
		</item>
	</channel>
</rss>

<!-- Performance optimized by W3 Total Cache. Learn more: http://www.w3-edge.com/wordpress-plugins/

Page Caching using disk: basic
Database Caching 33/39 queries in 0.100 seconds using disk: basic
Object Caching 725/752 objects using disk: basic

Served from: www.underflow.ca @ 2012-08-01 22:29:44 -->
<!-- Localized -->